##### Домашна работа 2

##### Задача 1:
##### От първия ред на стандартния вход се въвежда цялото число N (1 <= N <= 10000). От втория ред се въвеждат N на брой цели числа ai (0 <= ai <= 1000000). Всяко от тези числа се среща четен брой пъти в масива с изключение на едно единствено число, което се среща нечетен брой пъти. Задачата е да се изведе това число на стандартния изход.
##### Пример:
```c++
Вход:
11
1 3 2 8 3 2 8 1 3 2 2
Изход:
3
```

##### Задача 2:
##### От стандартния вход се въвежда цялото число sum (1 <= sum <= 10000). Задачата е да се напише рекурсивна функция, която намира по колко начина можем да получим sum като сбор на числата 2 и 3. Можем да си представяме, че разполагаме с 2 монети – едната със стойност 2, другата със стойност 3. От всяка монета имаме неограничено количество. На стандартния изход изведете търсения брой начини по които, събирайки неограничен брой 2-ки и 3-ки, можем да получим sum. 2 + 2 + 3 приемаме, че е същото като 3 + 2 + 2, т.е. броим го само веднъж.
##### Примери:
```c++
Вход:		Вход:		Вход:		Вход:		Вход:
10		20		100		1000		9973
Изход:	Изход:	Изход:	Изход:	Изход:
2		4		17		167		1662

Обяснение:
10 = 2 + 2 + 2 + 2 + 2
10 = 3 + 3 + 2 + 2
```

##### Задача 3:
##### Да се имплементира следната рекурсивна функция:
```c++
f(n) = 2 * f(n-1) + 3, ако n e четно, 
f(n) = 3 * f(n-1) + 2, ако n е нечетно,
f(0) = 0.
```

##### Пример:
```c++
Вход:
3
Изход:
23
```

##### Задача 4:
##### Да се напише функция int * occurences(int *&arr, int val1, int val2), която получава указател към масив от цели числа и стойност, след което присвоява на елементите от масива със стойност val1 стойността val2 и връща масив от цели числа, в който са индексите на всички променени елементи.

##### Задача 5:
##### Да се напише рекурсивна функция bool canReach(char **, int, int, int, int, int), която получава за аргументи (в този ред): указател към квадратна матрица от символи, представяща лабиринт, размер на матрицата, координати x и y на начален символ и координати x и y на краен символ, която проверява дали е възможно от началния символ да се достигне до крайния символ, без да се минава през 'стени'. В лабиринта стените са означени с '#', а позициите, през които е разрешено преминаването - с '.'. В main функцията да се въведе размер N и матрица NxN от потребителя, съответстваща на лабиринт, след което да се използва функцията за да се изведе дали съществува път от символ с координати (0,0) до символ с координати (N-1, N-1) (потребителя винаги въвежда '.' на позициите с тези координати). Позволена е промяната на матрицата с хода на функцията.
##### Примери:
```c++
Вход: 

3
.##
...
##.

Изход:
1

Вход:
4
....
.#.#
#.#.
....

Изход:
0
```

##### Всяка задача да бъде предадена като отделен .cpp файл.

